\chapter{Task 2}
\begin{parlist}
	\item Comparison:
	\begin{enumerate}
		\item Since in the waterfall model the requirements set for the system are "frozen" the cost to develop the system itself stay constant and doesn't add app during development. Also By completing a full design early in the project, changes to systems stay minimal, meaning the cost to fix and alter designs is kept low. Adding to this by having detailed documentation and designs, a project can lose key members without too much hassle since the documentation describes in reasonable detail how any subject-matter expert of the product or skill are needed to complete the work. So it shows that the waterfall models can be used by roughly three types of systems: 
			\begin{itemize}
				\item Embedded systems: because of hardware restrictions no change into the software requirements can be made after implementation
				\item Critical systems: since the safety is key word here, the process of security analysis must be thorough and the design documents must be complete to provide an effective analysis. 
				\item Large software system: where multiple partners and/or companies are involved. The system requirements must be unchanged to favour independent development, and the completion of such type of software and the withdrawal of any partner from the software should still guarantee the usability of the software afterwards.\cite{ibmDeveloper}\cite{Sommerville2015}
			\end{itemize}
		\item In the case of the waterfall model and in the context of a rapid changing world of requirements, by the time the software is available for use, the original reason for its procurement may have changed so radically that the software is effectively useless, instead the agile method would permit the process to adapt and to incorporate in an interleaved way the new requirements for the software. \\
			Also the waterfall model is not the right process model in situations where informal team communication is possible but instead the agile method permits as key principle: collective ownership in which developers work on all areas of the system, so that no islands of expertise develop and all the developers take responsibility for all of the code. Anyone can change anything.\cite{Sommerville2015}
	\end{enumerate}
	\item Zeitlich ist ein Projekt, das mit Extreme Programming \cite{enwiki:1150668036} durchgeführt wird,
in Versionen eingeteilt. Diese enden jeweils mit einer neuen Version des Softwaresystems. Am Anfang einer jeden Iteration besprechen der Kunde und die
Entwickler gemeinsam, welche Funktionalitäten realisiert werden sollen. Der Kunde
formuliert dabei seine Wünsche auf den SUD (engl.). Während der gesamten
Entwicklung ist der Kunde beteiligt. Er definiert zudem Akzeptanztests,
um Ende am jeder Iteration die Funktionalität testen zu können. Für die Entwickler gibt Extreme Programming zusätzlich eine Reihe von Praktiken vor, wie etwa
das nuzten von Code um Gedanken zu kommunizieren, das Respektieren von sich und anderen oder die gemeinsame Verantwortung.
\end{parlist}
